/* Copyright 2025 Andrea Bocci, Simeon Ehrig
 * SPDX-License-Identifier: MPL-2.0
 */

/*
 * C++20 compile-time demangled type name, based on
 *   https://www.reddit.com/r/cpp/comments/lfi6jt/finally_a_possibly_portable_way_to_convert_types/
 *   https://rodusek.com/posts/2021/03/09/getting-an-unmangled-type-name-at-compile-time/
 */

#pragma once

#include <array>
/** The following compilers does not use std::source_location therefore we do not include the header.
 * Including the header source_location would lead into compiler issues under the following conditions.
 *  - nvcc is used with clang 15 as host compiler and MDSpan is used too.
 *  error: `include/c++/11/source_location(53): error: identifier "__builtin_source_location" is undefined`
 */
#if !(defined(__GNUC__) || defined(__clang__) || defined(__PGI) || defined(__NVCOMPILER) || defined(_MSC_VER))
#    if defined(__cpp_lib_source_location)
#        include <source_location>
#    endif
#endif
#include <string_view>
#include <utility>

namespace alpaka::core
{

    namespace detail
    {

        // Generate a function name with full type signature that includes the user-provided type name.
        // Use the compiler-specific extensions for known compilers because nvc++ does not include the full type
        // signature in std::source_location::current().function_name() .
        template<typename T>
        consteval std::string_view embedTypeName()
        {
#if defined(__GNUC__) || defined(__clang__) || defined(__PGI) || defined(__NVCOMPILER)
            // gcc, clang, PGI, nvc++
            return __PRETTY_FUNCTION__;
#elif defined(_MSC_VER)
            // MSVC
            return __FUNCSIG__;
#elif defined(__cpp_lib_source_location)
            // unknown compiler, use the c++20 standard function_name()
            return std::source_location::current().function_name();
#else
            // std::source_location is not supported, fail
#    error                                                                                                            \
        "This compiler is not recognised and it does not support std::source_location. Please add explicit support to \"alpaka/core/DemangleTypeNames.hpp\"."
#endif
        }

        // Use a fundamental type to detect the prefix and suffix, because MSVC includes the class, struct, or union
        // keyword in the type signature.
        using TestPatternType = double;

        constexpr std::string_view testPatternName("double");

        // Embed the demangled type name into a function signature, then extract it and return it as a null-terminated
        // array of bytes.
        template<typename T>
        consteval auto demangleAsArray()
        {
            // Embed a known type, and use it to extract the prefix and suffix generated by the compiler.
            constexpr std::string_view embeddedPattern = embedTypeName<TestPatternType>();
            constexpr size_t prefixSize = embeddedPattern.find(testPatternName);
            constexpr size_t suffixSize = embeddedPattern.size() - prefixSize - testPatternName.size();

            // Embed T, and use the known prefix and suffix length to determien the type name's position and size.
            constexpr std::string_view embeddedType = embedTypeName<T>();
            constexpr size_t start = prefixSize;
            constexpr size_t end = embeddedType.size() - suffixSize;
            static_assert(start < end);
            constexpr size_t length = end - start;

            // Copy the demangled type name into an array, and add a null terminaton character
            std::array<char, length + 1> storage{};
            std::copy(embeddedType.data() + start, embeddedType.data() + end, storage.data());
            storage[length] = '\0';

            return storage;
        }

        // Store the demangled type name as a null-terminated array of bytes.
        // Note: this could be a function-static constexpr variable in c++23.
        template<typename T>
        inline constexpr auto storage = demangleAsArray<T>();

        // Return the demangled type name.
        template<typename T>
        consteval std::string_view demangle()
        {
            return std::string_view{storage<T>.data(), storage<T>.size()};
        }

    } // namespace detail

    // constexpr template string_view that contains the demangled type name.
    template<typename T>
    inline constexpr std::string_view demangled = detail::demangle<T>();

} // namespace alpaka::core
