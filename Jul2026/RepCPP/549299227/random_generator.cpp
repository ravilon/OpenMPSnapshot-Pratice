/* File:
 *     random_generator.cpp
 *
 *
 * Idea:
 *     Simulation of a game with a random number generator.  The game starts
 *     with integer SUM=0.  In each round, each students generate an integer in
 *     [-50, 100] and adds to SUM in turn.  The first student makes the SUM>1000
 *     wins the game.  Each student is simulated with a thread, and they share
 *     the variable SUM using the `critical` directive.
 *
 * Compile:
 *     g++ -g -Wall -fopenmp -o random_generator.out random_generator.cpp
 * Run:
 *     ./random_generator.out <thread_count>
 *
 * Input:
 *     None
 * Output:
 *     Numbers generated by each thread, and the winner of the game.
 */
#include <iostream>
#include <random>
#include <omp.h>
using namespace std;

/*-------------------------------------------------------------------
 * Function:  worker
 * Purpose:   Thread function that simulates the student
 */
void worker(int &sum, int &turn)
{
    int current_thread = omp_get_thread_num();
    default_random_engine generator{static_cast<unsigned int>(current_thread * 10)};
    uniform_int_distribution<int> distribution{ -50, 100 };

    while (sum <= 1000)
    {
        #pragma omp critical
        if (turn == current_thread && sum <= 1000)
        {
            // Confirm that the correct thread is running, and that the sum is
            //   within the range.
            int number = distribution(generator);
            sum += number;
            cout << "Thread " << current_thread << " generated " << number << ", "
                << "Sum: " << sum << endl;
            
            // If it's the thread that add the last number, it wins.
            if (sum >= 1000)
            {
                cout << "Thread " << current_thread << " wins!" << endl;
            }

            // Transfer the turn to the next thread.
            turn = (turn + 1) % omp_get_num_threads();
        }
    }
}


int main(int argc, char *argv[])
{
    // Get command line args
    int thread_count = stoi(argv[1]);

    int sum = 0, turn = 0;

    #pragma omp parallel num_threads(thread_count)
    worker(sum, turn);

    return 0;
}
